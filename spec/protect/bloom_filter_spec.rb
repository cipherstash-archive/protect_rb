require "cipherstash/protect/active_record_extensions/bloom_filter"

RSpec.describe CipherStash::Protect::ActiveRecordExtensions::BloomFilter do
  self::VALID_M_VALUES = [32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536]
  self::VALID_K_VALUES = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]

  # Generated by SecureRandom.hex(32)
  # The same key is used for each test run so that these tests are deterministic.
  let(:key) { "b6d6dba3be33ffaabb83af611ec043b9270dacdc7b3015ce2c36ba17cf2d3b2c" }
  let(:id) { "4f108250-53f8-013b-0bb5-0e015c998818" }
  let(:existing_test_key) { ENV["CS_PROTECT_KEY"] }

  before do
    ENV["CS_PROTECT_KEY"] = key
  end

  after do
     ENV["CS_PROTECT_KEY"] = existing_test_key
  end

  describe ".new" do
    it "raises an error if filter_size not provided" do
      expect {
        described_class.new(id)
      }.to raise_error(CipherStash::Protect::Error, "Invalid options provided. Expected filter_size and filter_term_bits.")
    end

    self::VALID_M_VALUES.each do |m|
      it "allows #{m} as a value for m" do
        filter = described_class.new(id, {filter_size:  m, filter_term_bits:  3})
        expect(filter.m).to eq(m)
      end
    end

    [0, 2, 16, 31, 513, 131072, "256", "ohai", nil, { foo: "bar" }, Object.new].each do |m|
      it "raises given invalid m of #{m.inspect}" do
        expect {
          described_class.new(id, {filter_size:  m, filter_term_bits:  3})
        }.to raise_error(CipherStash::Protect::Error, "filter_size must be a power of 2 between 32 and 65536 (got #{m.inspect})")
      end
    end

    it "raises an error if filter_term_bits not provided" do
      expect {
        described_class.new(id, {filter_size:  256})
      }.to raise_error(CipherStash::Protect::Error, "Invalid options provided. Expected filter_size and filter_term_bits.")
    end

    self::VALID_K_VALUES.each do |k|
      it "allows #{k} as a value for k" do
        filter = described_class.new(id, {filter_term_bits:  k, filter_size:  256})
        expect(filter.k).to eq(k)
      end
    end

    it "raises when k is < 3" do
      expect {
        described_class.new(id, {filter_term_bits:  2, filter_size:  256})
      }.to raise_error(CipherStash::Protect::Error, "filter_term_bits must be an integer between 3 and 16 (got 2)")
    end

    it "raises when k is > 16" do
      expect {
        described_class.new(id, {filter_term_bits:  17, filter_size:  256})
      }.to raise_error(CipherStash::Protect::Error, "filter_term_bits must be an integer between 3 and 16 (got 17)")
    end

    [3.5, "4", "ohai", nil, { foo: "bar" }, Object.new].each do |k|
      it "raises given invalid value of k #{k}" do
        expect {
          described_class.new(id, {filter_term_bits:  k, filter_size:  256})
        }.to raise_error(CipherStash::Protect::Error, "filter_term_bits must be an integer between 3 and 16 (got #{k.inspect})")
      end
    end

    it "raises when the key is too short" do
      ENV["CS_PROTECT_KEY"] = SecureRandom.hex(16)

      expect {
        described_class.new(id, {filter_term_bits:  16, filter_size:  256})
      }.to raise_error(CipherStash::Protect::Error, "Expected CS_PROTECT_KEY key to have length=64, got length=32. Use rake protect:generate_keys to create a key.")
    end

    it "raises when the key is empty" do
      ENV["CS_PROTECT_KEY"] = ""

      expect {
        described_class.new(id, {filter_term_bits:  16, filter_size:  256})
      }.to raise_error(CipherStash::Protect::Error, 'Invalid CS_PROTECT_KEY. Use rake protect:generate_keys to create a key, (got "")')
    end

    it "raises when the key is not a hex string" do
      ENV["CS_PROTECT_KEY"] = "ZZZ"

      expect {
        described_class.new(id, {filter_term_bits:  16, filter_size:  256})
      }.to raise_error(CipherStash::Protect::Error, 'Invalid CS_PROTECT_KEY. Use rake protect:generate_keys to create a key, (got "ZZZ")')
    end

    [nil, { foo: "bar" }.to_s, Object.new.to_s].each do |key|
      it "raises given invalid key #{key.inspect}" do
        ENV["CS_PROTECT_KEY"] = key
        expect {
          described_class.new(id, {filter_term_bits:  16, filter_size:  256})
        }.to raise_error(CipherStash::Protect::Error, "Invalid CS_PROTECT_KEY. Use rake protect:generate_keys to create a key, (got #{key.inspect})")
      end
    end
  end

  describe "#add" do
    before do
      ENV["CS_PROTECT_KEY"] = key
    end

    after do
      ENV["CS_PROTECT_KEY"] = nil
    end

    it "accepts a single term or a list of terms" do
      filter_a = described_class.new(id, {filter_term_bits:  16, filter_size:  256})
      filter_b = described_class.new(id, {filter_term_bits:  16, filter_size:  256})

      filter_a.add("abc")
      filter_b.add(["abc"])

      expect(filter_a.bits).not_to be_empty
      expect(filter_a.bits).to eq(filter_b.bits)
    end

    # In practice there will be 1 to k entries. Less than k entries will be in the set
    # in the case that any of the first k slices of the HMAC have the same value.
    it "adds k entries to bits for a single term when there are no hash collisions" do
      filter = described_class.new(id, {filter_term_bits:  3, filter_size:  256})
      # A term that's known to not have collisions in the first k slices for the test key
      filter.add("yes")

      expect(filter.bits.length).to eq(filter.k)
    end

    self::VALID_K_VALUES.each do |k|
      it "adds at most #{k} entries to bits for a single term when k=#{k}" do
        filter = described_class.new(id, {filter_term_bits:  k, filter_size:  256})
        random_term = SecureRandom.base64(3)

        filter.add(random_term)

        expect(filter.k).to eq(k)
        expect(filter.bits.length).to be > 0
        expect(filter.bits.length).to be <= filter.k
      end
    end

    self::VALID_M_VALUES.each do |m|
      it "adds bit positions with values >= 0 and < #{m} when m=#{m}" do
        filter = described_class.new(id, {filter_size:  m, filter_term_bits:  3})
        random_term = SecureRandom.base64(3)

        filter.add(random_term)

        expect(filter.m).to eq(m)
        expect(filter.bits.length).to be > 0
        expect(filter.bits.all? { |b| b < m }).to be(true), "expected all bit positions to be < #{m}, got bits=#{filter.bits.inspect}"
        expect(filter.bits.all? { |b| b >= 0 }).to be(true), "expected all bit positions to be >= 0, got bits=#{filter.bits.inspect}"
      end
    end

    it "returns the bloom filter instance" do
      filter = described_class.new(id, {filter_size:  256, filter_term_bits:  3})

      result = filter.add("yes")

      expect(result).to be(filter)
    end
  end

  describe "#subset?" do
    it "returns true when the other filter is a subset" do
      filter_a = described_class.new(id, {filter_size:  256, filter_term_bits:  3})
      filter_b = described_class.new(id, {filter_size:  256, filter_term_bits:  3})

      filter_a.add("yes")
      filter_b.add("yes")

      expect(filter_a).to be_subset(filter_b)
    end

    it "returns false when the other filter is not a subset" do
      filter_a = described_class.new(id, {filter_size:  256, filter_term_bits:  3})
      filter_b = described_class.new(id, {filter_size:  256, filter_term_bits:  3})

      filter_a.add("yes")
      filter_b.add("ner")

      expect(filter_a).not_to be_subset(filter_b)
    end

    self::VALID_M_VALUES
      .product(self::VALID_K_VALUES)
      .each do |m, k|
        it "works for m=#{m} and k=#{k}" do
          filter_a = described_class.new(id, {filter_size:  m, filter_term_bits:  k})
          filter_b = described_class.new(id, {filter_size:  m, filter_term_bits:  k})
          filter_c = described_class.new(id, {filter_size:  m, filter_term_bits:  k})
          filter_d = described_class.new(id, {filter_size:  m, filter_term_bits:  k})

          filter_a.add(%w(a b c))

          # subset of filter_a
          filter_b.add(%w(a b))

          # zero subset intersection with filter_a
          filter_c.add(%w(d e))

          # partial subset intersection with filter_a
          filter_d.add(%w(c d))

          expect(filter_b).to be_subset(filter_a)
          expect(filter_c).not_to be_subset(filter_a)
          expect(filter_d).not_to be_subset(filter_a)
        end
      end
  end

  describe "#to_a" do
    it "returns bits as an array" do
      filter = described_class.new(id, {filter_size:  256, filter_term_bits:  3}).add("a")

      expect(filter.to_a).to be_instance_of(Array)
      expect(Set.new(filter.to_a)).to eq(filter.bits)
    end
  end

  describe "#postgres_bits_from_native_bits" do
    it "offsets the bit positions by the @bloom_filter_offset value" do
      filter = described_class.new(id, {filter_size:  256, filter_term_bits:  3}).add("apple")

      bits = filter.to_a
      expect(bits).to eq([198, 137, 142])

      offset_bits = filter.postgres_bits_from_native_bits
      expect(offset_bits).to eq([-32570, -32631, -32626])

      reverted_offset_bits = offset_bits.map { |b| b + filter.postgres_offset }
      expect(bits).to eq(reverted_offset_bits)
    end
  end
end
